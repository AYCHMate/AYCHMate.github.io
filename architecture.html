---
layout: container
title: Security Architecture
permalink: /architecture/
stylesheets: ['/css/architecture.css']
---

<div class="container">
  <div class="row">
    <nav class="col-md-3 hidden-xs hidden-sm" id="subnav">
      <ul class="nav nav-pills nav-stacked">
        <li><a href="#virtualFilesystem">Virtual Filesystem</a></li>
        <li><a href="#masterkeyDerivation">Masterkey Derivation</a></li>
        <li><a href="#nameEncryption">Filename Encryption</a></li>
        <li><a href="#headerEncryption">File Header Encryption</a></li>
        <li><a href="#sizeObfuscation">File Size Obfuscation</a></li>
        <li><a href="#contentEncryption">File Content Encryption</a></li>
        <li><a href="#nameShortening">Name Shortening</a></li>
        <li><a href="#storage">Target Directory</a></li>
      </ul>
    </nav>

    <div class="col-md-offset-3 col-md-9 col-xs-12">
      <article id="virtualFilesystem" class="layer-explanation">
        <h2>Virtual Filesystem</h2>
        <p class="lead">Cryptomator provides a virtual drive. Add, edit, remove files as you're used to with just any disk drive.</p>
        <p>Currently WebDAV is our frontend of choice, as it is supported on every major operating system. WebDAV is an HTTP-based protocol, in which Cryptomator acts as a server accepting so-called loopback connections on your local machine only. Whenever your file manager accesses files through this protocol, Cryptomator will process this request via the following layers.</p>
      </article>

      <article id="masterkeyDerivation" class="layer-explanation">
        <h2>Masterkey Derivation</h2>
        <p class="lead">Each vault has its own 256 bit encryption as well as MAC masterkey used for encryption of file specific keys and file authentication respectively.</p>
        <p>These keys are random sequences generated by a <abbr title="Cryptographically secure pseudorandom number generator" class="initialism">CSPRNG</abbr>.</p>
        <p>Both keys are encrypted using <a href="https://tools.ietf.org/html/rfc3394" target="_blank">RFC 3394</a> key wrapping with a <abbr title="Key encrypting key" class="initialism">KEK</abbr> derived from the user's password using Scrypt.<p>
<pre>
encryptionMasterKey := createRandomBytes(32)
macMasterKey := createRandomBytes(32)
kek := scrypt(password, scryptSalt, scryptCostParam, scryptBlockSize)
wrappedEncryptionMasterKey := aesKeyWrap(encryptionMasterKey, kek)
wrappedMacMasterKey := aesKeyWrap(macMasterKey, kek)
</pre>
          <p>The wrapped keys and the parameters needed to derive the KEK are then stored as integers or Base64 strings in a JSON file named <code>masterkey.cryptomator</code>, which is located in the root directory of the vault.</p>
          <p>When unlocking a vault the KEK is used to unwrap (i.e. decrypt) the stored masterkeys.</p>
<pre>
{
  "version": 3, /* vault version for checking software compatibility */
  "scryptSalt": "QGk...jY=",
  "scryptCostParam": 16384,
  "scryptBlockSize": 8,
  "primaryMasterKey": "QDi...Q==", /* wrappedEncryptionMasterKey */
  "hmacMasterKey": "L83...Q==", /* wrappedMacMasterKey */
  "versionMac": "3/U...9Q=" /* HMAC-256 of vault version to prevent downgrade attacks */
}
</pre>
      </article>

      <article id="nameEncryption" class="layer-explanation">
        <h2>Filename Encryption</h2>
        <p class="lead">Before we deal with the actual file contents, filenames get encrypted.</p>
        <p>Cryptomator uses AES-SIV to encrypt file as well as directory names. Additionally to the name a unique directory ID of its parent directory is passed as associated data.</p>
<pre>
cipheredName := base32(aesSiv(cleartextName, parentDirId, encryptionMasterKey, macMasterKey))
</pre>
        <p>If it's a filename, we're done!</p>
        <p>If it's a directory name, we append an underscore. We then create a file with this name, in which we write a unique identifier (e.g. <abbr title="Universally unique identifier" class="initialism">UUID</abbr>). The corresponding directory however is stored in a different location:</p>
<pre>
dirId := createUuid()
dirIdHash := base32(sha1(aesSiv(dirId, null, encryptionMasterKey, macMasterKey)))
dirPath := vaultRoot + '/d/' + substr(dirIdHash, 0, 2) + '/' + substr(dirIdHash, 2, 30)
</pre>
        <p>By making all directories effectively siblings (or cousins to be precise), we not only obfuscate the directory hierarchy but also limit path depth regardless of its actual hierarchy to ensure compatiblity with some cloud services.</p>
      </article>

      <article id="headerEncryption" class="layer-explanation">
        <h2>File Header Encryption</h2>
        <p class="lead">The file header stores certain metadata, which is needed for file content encryption. It consists of 88 bytes.</p>
        <ul>
          <li>16 bytes nonce used during header payload encryption</li>
          <li>
            40 bytes AES-CTR encrypted payload consisting of:
            <ul>
              <li>8 bytes file size</li>
              <li>32 bytes file content key</li>
            </ul>
          </li>
          <li>32 bytes header MAC of the previous 56 bytes</li>
        </ul>
<pre>
headerNonce := createRandomBytes(16)
contentKey := createRandomBytes(32)
cleartextPayload := bigEndian(fileSize) . contentKey
ciphertextPayload := aesCtr(cleartextPayload, encryptionMasterKey, headerNonce)
mac := hmacSha256(headerNonce . ciphertextPayload, macMasterKey)
</pre>
      </article>

      <article id="sizeObfuscation" class="layer-explanation">
        <h2>File Size Obfuscation</h2>
        <p class="lead">To make it difficult to recognize a file based on a known size, a random-length padding is appended before encryption.</p>
        <p>Of course, the padding should be of an appropriate length, so we make its upper bound depend on the real file size.</p>
<pre>
upperBound := max(min(10% * realFileSize, 16MiB), 4KiB)
paddingLength := randomInt(upperBound)
</pre>
        <p>The random padding length will be up to 10% of your real file size, but at least 0-4 KiB and not more than 16 MiB.</p>
        <p>The content of the padding itself is unspecified as the real file size is stored in the file header and sufficient to determine the end of the real content.</p>
      </article>

      <article id="contentEncryption" class="layer-explanation">
        <h2>File Content Encryption</h2>
        <p class="lead">This is where your actual file contents get encrypted.</p>
        <p>The cleartext is broken down into multiple chunks, each up to 32 KiB + 48 bytes consisting of:</p>
        <ul>
          <li>16 bytes nonce</li>
          <li>up to 32 KiB encrypted payload using AES-CTR with the file content key</li>
          <li>
            32 bytes MAC of
            <ul>
              <li>file header nonce (to bind this chunk to the file header)</li>
              <li>chunk number as 8 byte big endian integer (to prevent reordering)</li>
              <li>nonce</li>
              <li>encrypted payload</li>
            </ul>
          </li>
        </ul>
        <p>Afterwards the encrypted chunks are joined preserving the order of the cleartext chunks. The payload of the last chunk may be smaller than 32 KiB.</p>
<pre>
cleartextChunks[] := split(paddedCleartext, 32KiB)
for (int i = 0; i < length(cleartextChunks); i++) {
  chunkNonce := createRandomBytes(16)
  encryptedPayload := aesCtr(cleartextChunks[i], fileKey, chunkNonce)
  mac := hmacSha256(headerNonce . bigEndian(i) . chunkNonce . encryptedPayload, macMasterKey)
  ciphertextChunks[i] := chunkNonce . encryptedPayload . mac
}
encryptedFileContent := join(encryptedChunks[])
</pre>
      </article>

      <article id="nameShortening" class="layer-explanation">
        <h2>Name Shortening</h2>
        <p class="lead">This layer doesn't modify any file contents. Its sole purpose is to limit the path length to ensure compatibility with certain Microsoft products, that are stuck in the '90s.</p>
        <p>Even with the flattened directory structure <a href="#nameEncryption">achieved during filename encryption</a>, the file path might be longer than 255 characters. So whenever a filename reaches a certain threshold, it is replaced by its much shorter SHA-1 hash and gets a <code>.lng</code> file extension. Additionally an equally named metadata file is created in the <code>m</code> directory containing a reverse-mapping back to the original name.</p>
        <p>This layer doesn't provide any additional security. Its sole purpose is to maximize compatibility.</p>
      </article>

      <article id="storage" class="layer-explanation">
        <h2>Target Directory</h2>
        <p class="lead">After your files have been processed by all above layers, they are finally stored into your chosen directory.</p>
        <p>This is where Cryptomator's job is done and the synchronization client of your favorite cloud provider will start synchronization.</p>
      </article>
    </div>

  </div>
</div>
